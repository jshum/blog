---
layout: post
title: "What Software Engineers do? Draft notes"
tldr: ""
tags: [cs, relationships, management, jobs]
---

May 6, 2013

premise : I think I wrote this after getting my job and feeling a little disillusioned by all the buzz words that kept changing. 

Advancing in tech

Tech changes every day. New different technologies are always cropping up, displacing the old tech, creating new buzzwords, frameworks and conventions. 

This is particularly bad in front-end development which goes through fads of one particular js package being used by everyone. Many have beef with the new super slick js libraries, saying they just repackage the problem and put it somewhere else. 

The two things that don't change are physics and math. 

It's easy to get caught in the whole software engineering craze when you enter industry. 

Computer science as a field though suffers from this, doing the same problem in a slightly different way and claiming it has lots of benefits over the other way.

there are so many competing technologies and everyone claims they're the best. and putting that in perspective in the hype cycle. hadoop is on the height of the hype cycle now.

demands for certain skills rise and drop drastically over short periods of time. 

the key is to know enough on how to describe it on a high level, the situations to take advantage of it, but not worry too much about specific implementation details unless your job title is 'subject x expert'

it's important to look back at the classics, the things have still remained after many many years.

and i think software engineering in particular becomes a lot more about effort/work management rather than tech. a component programmer can work in any language in any stack after he spends the time to understand it. so the challenege becomes how do you organize teams/groups/development cycles so that the maximum number of innovations happen per unit time.

code is a very organic thing. it's logical like math, but it can become arbitrarily complicated, because the pieces are grown from a developer's relationship with it, a customers' relationship with it, and the interactions among different parts of the code.

that's why there's this whole problem with legacy code in swe. understanding the code base would take as long or longer than rewriting the whole thing, but no top-level executive is ever willing to throw away legacy code, because that states that all the money has been wasted.

for data science, math provides the tools but the subject matter can be anything. why is why the much more important question is what do you want to study/understand? for me, that's still an open question.

social sciences seem to be a large testing ground for data science. there's so much you can study, none of which could give you any conclusive results. 

http://blog.plover.com/math/topology-doc.html

* with technologies
    * hype cycle, catching up, no coasting
* with codebase
    * tooling, bugs, architecture
* organization's goals, 
    * best measure of an engineering team is how much the dev team learns.
    * swe's spend time writing code, debugging code and performing one-off tasks

