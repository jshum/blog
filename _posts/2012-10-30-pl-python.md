---
layout: post
title: "type sigs"
---

By the virtue of using racket, everything is an expression, because the last value is automatically returned/yielded.
In the past statements were subset of expressions, x++, automatically yielded the original x value
Now, we are flipping it. expressions are a subset of statements, which means statements don't return any value

why we need a store in parseltongue?
defvar a = 0 in {
defvar b = 3 in {
deffun x(a)
	a = a + 1
in {
print(x(b)) 
}}}
If we just pass around an environment of the form (symbol-> value), then we would have rewritten
the value of a =0 with a = 4 from interpping the funtion body
In python, the changes made inside a function are no longer visible outside.

store passing style: We were using store-passing style because we were trying to implement 
mutation in a host language that doesn't have mutation. So we took in a list of values, made some changes
and passed it onto the next statement

global store
* We can use a global store now because we can rely on set! or hash-set of our host language

interp\-stmt : (listof Stmt)*Env*Context -> None | Exn(val)
* Env : the environment needs to be passed so we store it. You don't want to have a global env. 
	* The environment is immutable which means when we change it, we create a new copy of it.
* Context : to know if we are in fundef/classdef because there are things we can do in a fundef but not in a classdef

type-case
* Fundef : set "name" to ( VClosure args body env) in store.
	* all the variables declared before the fundef are viewable by the function but not editable.
* Classdef : set "name" to (VClass env attributes )   //this would actually be preferred
	* all the variables declared before the fundef are viewable by the function but not editable.
	* you could also interp all the attributes, bind each of them one into the store, and close over the store
	* but there shouldn't be any way to reach local variables created inside the class def, which means we should ignore all non attribute things. all that remains are attributes
	* 
* Classdef : set "name" to (VObj env attirbutes) //because all things in python share the same namespace.
    >>> class C: pass
    >>> c = C()
    >>> type(c)
    >>> C = C()
    >>> c = C()
    C not callable
* Assign :
* Return : 
* If : 
* Raise : 
* TryExcept : 
* Global : 
* Nonlocal : 
* Pass :
* Continue : 
* Break : 
* SExpr

inter-expr : (expr)*env-> value | Exn
* App
	* this could have side effects
* Lambda
* Num
* Object
* True
* False

