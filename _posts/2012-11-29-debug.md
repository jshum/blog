---
layout: post
title: "the philosophy of debugging"
---

First remark
a) dynamic memory management is really quite an interesting system topic. you have to very explicitly think about the space-time tradeoffs here. and the only thing that's going to give you a definite space and performance increase is hardware improvement.

Second remark
how do you debug
1. for most computer science curriculums, first year classes are taught using "higher level" programming langauges i.e. java, python, scheme
	* it's fine for an intro class. however, students then start to rely on the language's built-in features i.e. java will tell you when you're trying to an out of bound index, or when you have a key error.
2. that friendliness is gone once you use a language like C. all you will see from now on is the infamous Segmentation Fault. Typically, these are the behaviors I observe
	* level 0: student looks at code and doesn't know why it's wrong
	* level 1: student runs their code in gdb and knows which line the error is on and examines that line intently
	* level 2: student prints out the values used in that line which it segfaulted on.
3. For bugs, even  more so with memory bugs, it will often be the case that the error is a result of an invalid operation many lines ago.
4. bugs occur when what you think wasn't going to happen did in fact occur OR what you did think was going to happen didn't happen.
5. so the philosophy of debugging is simply to CONFRONT THE FACTS. 
	* Isolate the problem, try to build a smaller and smaller scenario until you can no longer recreate your bug.
	* Find the facts and scruntinize them. Start from the smallest guarantee and build it up. Assume everything is wrong and prove that your program is right with facts.
	* Debugging means providing yourself with the context information on where the bug was created, where did things started looking fishy?
6. in practice, this can mean one of two things. checkers: use asserts to prove your program is right. printlines: provide yourself with the context information. and write simple test files to recreate your bug.

Debugging is a skill that you just get better with. But always be efficient about debugging. Debugging isn't measured by how much time you spent finding the bug but on how many different things you tried to find where the bug originated from.

Many of you are used to using "higher level" programming langauges i.e. Java, Python, Scheme which provide helpful error messages when your program crashes.
That friendliness is gone when we're using a language like C. All you will see from now on is the infamous Segmentation Fault. Typically, these are the debugging behaviors we have observed 
0: Student looks at code and doesn't know why it's wrong.
1: Student runs their code in gdb and knows which line the error is on and examines that line and only that line intently.
2: Student prints out the values used in that line which it segfaulted on.
For bugs, and even more so with memory bugs, it will often be the case that the error is a result of an invalid operation many lines ago. This means you can't just inspect the code where the Segfault occured on. You have to look at more code and potentially all of the code that led to the segfault. Bugs occur when what you think wasn't going to happen did in fact occur OR what you did think was going to happen didn't happen. Thus, the philosophy of debugging is simply to CONFRONT THE FACTS. 
	Isolate the problem, try to build a smaller and smaller scenario until you can no longer recreate your bug.
	Find the facts and scruntinize them. Start from the smallest guarantee and build it up. Assume everything is wrong and prove that your program is right with facts.
	Debugging means providing yourself with the context information on where the bug was created, where did things started looking fishy?
In practice, this can mean one of two things. checkers: use asserts to prove your program is right. printlines: provide yourself with the context information. and write simple test files to recreate your bug.
Debugging is a skill that you just get better with. But always be efficient about debugging. Debugging isn't measured by how much time you spent finding the bug but on how many different things you tried to find where the bug originated from.



