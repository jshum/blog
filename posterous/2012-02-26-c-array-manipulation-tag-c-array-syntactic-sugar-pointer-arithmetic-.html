---
layout: post
title: ! 'C array manipulation ((tag: c, array, syntactic sugar, pointer arithmetic)'
published: true
---
<div>VARIABLE NUMBER OF ELEMENTS IN OBJECT.</div><div>tags</div><p />arrays can only be compiled if their sizes are known at compile time. <div>so array[var] does not work. </div><p /><div>what you do instead is declare an array with zero elements for its pointer.</div> <div>since array referencing is really just pointer arithmetic. </div><div>var[num] = *(var + num)</div><p /><div>the following are equivalent:</div><div>age[0] = 0[age]</div><div>age[1] = 1[age]</div><div> age[2] = 2[age]</div><div>age[3] = 3[age]</div><p /><div>more info, go to bottom of <a href="http://augustcouncil.com/~tgibson/tutorial/arr.html">http://augustcouncil.com/~tgibson/tutorial/arr.html</a></div> <p /><div>but the point is that the C compiler doesn&#39;t really know what you&#39;re trying to reference,</div><div>so you can use the following &quot;HACK&quot;:</div><p />typedef struct array {<br />   int  capacity;  // the number of elements the array actually holds<br />   int *elems[0];  // an array that supposedly holds 0 elements<br />} array_t;<p />// create an array_t with room for 10 elements and initialize one element<br /> // note that sizeof(array_t) is not sufficient to store any elements<br />array_t *arr  = (array_t *) malloc(sizeof(array_t) + 10 * sizeof(int));<br />arr-&gt;capacity = 10;<br />arr-&gt;elems[8] = 10000; // works because array indices are not checked in C
